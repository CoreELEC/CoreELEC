set -e

# setup initial directorys (relative to root)
  CONFIG=config
  SCRIPTS=scripts
  PACKAGES=packages
  SOURCES=${SOURCES_DIR:-$ROOT/sources}
  BUILD_BASE=build
  TARGET_IMG=${TARGET_DIR:-$ROOT/target}
  ADDONS=addons

# include ARCH specific options
  if [ -f config/arch.$TARGET_ARCH ]; then
    . config/arch.$TARGET_ARCH
  fi

[ -z "${HOST_NAME}" ] && export HOST_NAME="$($LOCAL_CC -dumpmachine)"
TARGET_NAME=$TARGET_GCC_ARCH-libreelec-linux-gnu${TARGET_ABI}

BUILD=$ROOT/$BUILD_BASE.$DISTRONAME-${DEVICE:-$PROJECT}.$TARGET_ARCH-$LIBREELEC_VERSION
if [ "$LIBREELEC_VERSION" = "devel" ] ; then
  BUILD=$ROOT/$BUILD_BASE.$DISTRONAME-${DEVICE:-$PROJECT}.$TARGET_ARCH-$OS_VERSION-$LIBREELEC_VERSION
fi

if [ -n "$BUILD_SUFFIX" ]; then
  BUILD=$BUILD-$BUILD_SUFFIX
fi

TARGET_ADDONS="$TARGET_IMG/$ADDONS/$ADDON_PATH"
ADDON_BUILD="$BUILD/$ADDONS/$1"
STAMPS_NOARCH=.stamps
STAMPS=$BUILD/.stamps
STAMPS_INSTALL=$BUILD/image/.stamps
DOCS=DOCS
TOOLCHAIN=$BUILD/toolchain
SYSROOT_PREFIX=$TOOLCHAIN/$TARGET_NAME/sysroot
LIB_PREFIX=$SYSROOT_PREFIX/usr
TARGET_PREFIX=$TOOLCHAIN/bin/$TARGET_NAME-

# use linaro toolchain on 64/32 split builds
if [ -z "$KERNEL_LINARO_TOOLCHAIN" -a "$TARGET_KERNEL_ARCH" = "arm64" -a "$TARGET_ARCH" = "arm" ]; then
  KERNEL_LINARO_TOOLCHAIN="aarch64-linux-gnu"
fi
if [ -n "$KERNEL_LINARO_TOOLCHAIN" ]; then
  TARGET_KERNEL_PREFIX=$TOOLCHAIN/lib/gcc-linaro-$KERNEL_LINARO_TOOLCHAIN/bin/$KERNEL_LINARO_TOOLCHAIN-
else
  TARGET_KERNEL_PREFIX=$TARGET_PREFIX
fi

FAKEROOT_SCRIPT=$BUILD/.fakeroot

if [ -z "$INSTALL" ]; then
  INSTALL=$BUILD/image/system
fi
INSTALL_INIT=$BUILD/image/initramfs/root-image

. config/sources

MAKE="$TOOLCHAIN/bin/make"
MAKEINSTALL="$TOOLCHAIN/bin/make -j1 DESTDIR=$SYSROOT_PREFIX install"

unset LD_LIBRARY_PATH

# Don't use BUILD_WITH_DEBUG in "gloabl" package.mk - instead, call the function
# build_with_debug() directly as the function depends on various package.mk
# variables that will be in the process of being configured. Once package.mk is
# fully sourced we can set this variable and use it in situations where we know the
# package has already been sourced.
unset BUILD_WITH_DEBUG

# If the package caches are unset, then populate them
init_package_cache

# set package metadata
reset_pkg_vars "$1"

[ -n "$1" ] && PKG_DIR="$(get_pkg_directory $1)"

if [ -n "$PKG_DIR" -a -r $PKG_DIR/package.mk ]; then
  unset -f configure_package
  . $PKG_DIR/package.mk
  [ -z "$PKG_SHORTDESC" ] && PKG_SHORTDESC="$PKG_NAME (autogenerated)"
  [ -z "$PKG_LONGDESC" ] &&  PKG_LONGDESC="$PKG_NAME (autogenerated)"
fi

if [ "$PKG_IS_ADDON" = "yes" -o "$PKG_IS_ADDON" = "embedded" ] ; then
  [ -z $PKG_SECTION ] && PKG_ADDON_ID="$PKG_NAME" || PKG_ADDON_ID="${PKG_SECTION//\//.}.$PKG_NAME"
  [ "$PKG_ADDON_IS_STANDALONE" != "yes" ] && PKG_NEED_UNPACK="${PKG_NEED_UNPACK} $(get_pkg_directory $MEDIACENTER)"
fi

# Automatically set PKG_SOURCE_NAME unless it is already defined.
# PKG_SOURCE_NAME will be automatically set to a name based on
# the $PKG_NAME-$PKG_VERSION convention.
#
# Any $PKG_URL that references more than a single url will abort
# the build as these are no longer supported - use mkpkg instead.
if [ -n "$PKG_URL" -a -z "$PKG_SOURCE_NAME" ]; then
  if [[ $PKG_URL =~ .*\ .* ]]; then
    echo "Error - packages with multiple urls are no longer supported, use mkpkg:"
    echo "$PKG_URL"
    exit 1
  fi
  if [[ ${PKG_URL} =~ .git$ || ${PKG_URL} =~ ^git:// ]]; then
    PKG_SOURCE_NAME=${PKG_NAME}-${PKG_VERSION}
  elif [[ ${PKG_URL} =~ ^file:// ]]; then
    PKG_SOURCE_NAME=${PKG_URL#file://}
    # if no specific PKG_TAR_COPY_OPTS then default to excluding .git and .svn as they can be huge
    [ -z "${PKG_TAR_COPY_OPTS+x}" ] && PKG_TAR_COPY_OPTS="--exclude=.git --exclude=.svn"
  else
    PKG_SOURCE_NAME="${PKG_URL##*/}"
    case $PKG_SOURCE_NAME in
      ${PKG_NAME}-${PKG_VERSION}.*)
        PKG_SOURCE_NAME=$PKG_SOURCE_NAME
        ;;
      *.tar | *.tbz | *.tgz | *.txz | *.7z | *.zip)
        PKG_SOURCE_NAME=${PKG_NAME}-${PKG_VERSION}.${PKG_SOURCE_NAME##*\.}
        ;;
      *.tar.bz2 | *.tar.gz | *.tar.xz)
        PKG_SOURCE_NAME=${PKG_NAME}-${PKG_VERSION}.tar.${PKG_SOURCE_NAME##*\.}
        ;;
      *.diff | *.patch | *.diff.bz2 | *.patch.bz2 | patch-*.bz2 | *.diff.gz | *.patch.gz | patch-*.gz)
        PKG_SOURCE_NAME=$PKG_SOURCE_NAME
        ;;
      *)
        PKG_SOURCE_NAME=${PKG_NAME}-${PKG_VERSION}.${PKG_SOURCE_NAME##*\.}
        ;;
    esac
  fi
fi

PKG_BUILD="$BUILD/${PKG_NAME}-${PKG_VERSION}"

build_with_debug && BUILD_WITH_DEBUG="yes" || BUILD_WITH_DEBUG="no"

XORG_PATH_DRI=/usr/lib/dri
XORG_PATH_XKB=/usr/share/X11/xkb
XORG_PATH_XKB_OUTPUT=/var/lib/xkb
XORG_PATH_RGB=/usr/lib/X11/rgb
XORG_PATH_MODULES=/usr/lib/xorg/modules
XORG_PATH_DRIVERS=/usr/lib/xorg/modules/drivers

. config/optimize

if [ -z "$CCACHE_DIR" ]; then
  export CCACHE_DIR=$BUILD/.ccache
fi

if [[ -z "$PATH" || ( "$PATH" != "$TOOLCHAIN/bin:$TOOLCHAIN/sbin" && "$PATH" = "${PATH#$TOOLCHAIN/bin:$TOOLCHAIN/sbin:}" ) ]]; then
  export PATH="$TOOLCHAIN/bin:$TOOLCHAIN/sbin${PATH:+":$PATH"}"
fi

VERSION_SUFFIX=$TARGET_ARCH

SILENT_OUT=3
VERBOSE_OUT=4
if [ "$VERBOSE" = yes ]; then
  exec 3>&1
  exec 4>&2
else
  exec 3>&2
  exec 4>/dev/null
fi
BUILD_INDENT_SIZE=4

# If sourcing a package, configure any package variables dependent on variables we have set
if [ -n "$PKG_DIR" -a -r $PKG_DIR/package.mk ]; then
  pkg_call_optional configure_package
fi

# multilib? nah
unset CONFIG_SITE

# meh suse
unset PYTHONSTARTUP
unset PYTHONPATH
